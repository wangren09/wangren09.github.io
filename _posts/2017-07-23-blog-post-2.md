---
title: 'Backtracking'
date: 2017-07-23
permalink: /posts/2017/07/23/blog-post-2/
---

I am a Ph.D candidate in Electrical Engineering at Rensselaer Polytechnic Institute (RPI), Department of Electrical, Computer & Systems Engineering under the supervision of Prof. Meng Wang. I obtained my M.S. at University of Pennsylvania (Penn), and received my B.S. (with honors) in Electronic and Information Engineering from Xidian University. My research interests lie in the intersection of the fields of signal processing, high-dimensional statistics, and machine learning.

I am a Ph.D candidate in Electrical Engineering at Rensselaer Polytechnic Institute (RPI), Department of Electrical, Computer & Systems Engineering under the supervision of Prof. Meng Wang. I obtained my M.S. at University of Pennsylvania (Penn), and received my B.S. (with honors) in Electronic and Information Engineering from Xidian University. My research interests lie in the intersection of the fields of signal processing, high-dimensional statistics, and machine learning.

I am a Ph.D candidate in Electrical Engineering at Rensselaer Polytechnic Institute (RPI), Department of Electrical, Computer & Systems Engineering under the supervision of Prof. Meng Wang. I obtained my M.S. at University of Pennsylvania (Penn), and received my B.S. (with honors) in Electronic and Information Engineering from Xidian University. My research interests lie in the intersection of the fields of signal processing, high-dimensional statistics, and machine learning.

I am a Ph.D candidate in Electrical Engineering at Rensselaer Polytechnic Institute (RPI), Department of Electrical, Computer & Systems Engineering under the supervision of Prof. Meng Wang. I obtained my M.S. at University of Pennsylvania (Penn), and received my B.S. (with honors) in Electronic and Information Engineering from Xidian University. My research interests lie in the intersection of the fields of signal processing, high-dimensional statistics, and machine learning.



## 17. Letter Combinations of a Phone Number
<pre>
class Solution(object):

    def __init__(self):
        self.dict = {'0':[' '],
                     '1':['*'],
                     '2':['a','b','c'],
                     '3':['d','e','f'],
                     '4':['g','h','i'],
                     '5':['j','k','l'],
                     '6':['m','n','o'],
                     '7':['p','q','r','s'],
                     '8':['t','u','v'],
                     '9':['w','x','y','z'],
                     '' :[]}
    
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if len(digits) <= 1:
            return self.dict[digits]
        left = digits[0]
        right = self.letterCombinations(digits[1:])
        res = []
        for i in range(len(self.dict[left])):
            for j in range(len(right)):
                res.append(self.dict[left][i]+right[j])
        return res
</pre>
Time Complexity: O(4^n), Space Complexity: O(n*4^n).

## 22. Generate Parentheses
<pre>
class Solution(object):
    
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        res = []
        self.helper(0, 0, '', n, res)
        return res
        
    def helper(self, l, r, path, n, res):
        if l == n  and r == n:
            res.append(path)
            return
        if l < n:
            self.helper(l+1, r, path+'(', n, res)
        if l > r:
            self.helper(l, r+1, path+')', n, res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 39. Combination Sum
<pre>
class Solution(object):
    
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(0, candidates, target, [], res)
        return res
        
    def helper(self, index, candidates, target, path, res):
        if sum(path) > target:
            return
        elif sum(path) == target:
            res.append(path)
            return
        else:
            for i in range(index, len(candidates)):
                self.helper(i, candidates, target, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).
