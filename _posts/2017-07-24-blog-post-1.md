---
title: 'Array'
date: 2017-07-24
permalink: /posts/2017/07/24/blog-post-1/
---

It is hard to summarize a general method for this category. Instead I will provide some ideas for some of the problems.

## 1. Two Sum
<pre>
class Solution(object):
    
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        if len(nums) <= 1:
            return False
        dict = {}
        for i in range(len(nums)):
            if nums[i] in dict:
                return [dict[nums[i]],i]
            else:
                dict[target-nums[i]] = i
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 11. Container With Most Water
Idea: Set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan.
<pre>
class Solution(object):
    
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l = 0
        r = len(height)-1
        res = 0
        while l < r:
            res = max(res, min(height[l], height[r])*(r-l))
            if height[l] <= height[r]:
                l += 1
            else:
                r -= 1
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 15. 3Sum
<pre>
class Solution(object):
    
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = set()
        nums = sorted(nums)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            dict = {}
            target = -nums[i]
            for j in range(i+1, len(nums)):
                if nums[j] in dict:
                    res.add(tuple([nums[i], nums[dict[nums[j]]], nums[j]]))
                else:
                    dict[target-nums[j]] = j
        return list(res)
</pre>
Time Complexity: O(n^2), Space Complexity: max(O(size of "res"), O(size of "dict")).

## 16. 3Sum Closest
<pre>
class Solution(object):
    
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums = sorted(nums)
        res = nums[0]+nums[1]+nums[2]
        for i in range(len(nums)):
            l = i+1
            r = len(nums)-1
            while l < r:
                sum = nums[i]+nums[l]+nums[r]
                if sum == target:
                    return sum
                if abs(sum-target) < abs(res-target):
                    res = sum
                if sum > target:
                    r -= 1
                if sum < target:
                    l += 1
        return res
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 18. 4Sum
<pre>
class Solution(object):
    
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums = sorted(nums)
        n = len(nums)
        res = set()
        for i in range(n):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            for j in range(i+1, n):
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                dict = {}
                aim = target-nums[i]-nums[j]
                for k in range(j+1, n):
                    if nums[k] in dict:
                        res.add(tuple([nums[i], nums[j], nums[dict[nums[k]]], nums[k]]))
                    else:
                        dict[aim-nums[k]] = k
        return list(res)
</pre>
Time Complexity: O(n^3), Space Complexity: max(O(size of "res"), O(size of "dict")).

## 26. Remove Duplicates from Sorted Array
<pre>
class Solution(object):
    
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        length = 0
        i = 0
        while i < len(nums):
            if i == 0 or nums[i-1] != nums[i]:
                nums[length] = nums[i]
                length = length+1
            i = i+1
        return length
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 27. Remove Element
<pre>
class Solution(object):
    
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        length = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[length] = nums[i]
                length += 1
        return length
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 31. Next Permutation
<pre>
class Solution(object):
    
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        r = len(nums)-1
        while nums[r] <= nums[r-1] and r > 0:
            r -= 1
        if r == 0:
            nums.reverse()
        else:    
            i = len(nums)-1
            while nums[i] <= nums[r-1]:
                i -= 1             
            nums[r-1], nums[i] = nums[i], nums[r-1]
            nums[r:] = nums[r:][::-1]   
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 33. Search in Rotated Sorted Array
<pre>
class Solution(object):
    
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        l = 0
        r = len(nums)-1
        while l <= r:
            mid = (l+r)/2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[l]:
                if nums[l] <= target < nums[mid]:
                    r = mid-1
                else:
                    l = mid+1
            else:
                if nums[mid] < target <= nums[r]:
                    l = mid+1
                else:
                    r = mid-1
        return -1
</pre>
Time Complexity: O(log(n)), Space Complexity: O(1).

## 34. Search for a Range
<pre>
</pre>

## 35. Search Insert Position
<pre>
class Solution(object):
    
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        l = 0
        r = len(nums)-1
        if target > nums[r]:
            return r+1
        while l < r:
            mid = (l+r)/2
            if nums[mid] == target:
                return mid
            if nums[mid] < target:
                l = mid+1
            if nums[mid] > target:
                r = mid
        return r
</pre>
Time Complexity: O(log(n)), Space Complexity: O(1).

## 39. Combination Sum
<pre>
class Solution(object):
    
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(0, candidates, target, [], res)
        return res
        
    def helper(self, index, candidates, target, path, res):
        if sum(path) > target:
            return
        elif sum(path) == target:
            res.append(path)
            return
        else:
            for i in range(index, len(candidates)):
                self.helper(i, candidates, target, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 40. Combination Sum II
<pre>
class Solution(object):
    
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(0, sorted(candidates), target, [], res)
        return res
        
    def helper(self, index, candidates, target, path, res):
        if sum(path) > target:
            return
        elif sum(path) == target:
            res.append(path)
            return
        else:
            for i in range(index, len(candidates)):
                if i > index and candidates[i] == candidates[i-1]:
                    continue
                else:
                    self.helper(i+1, candidates, target, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 48. Rotate Image
Pay attention to the copy of the matrix.
<pre>
class Solution(object):
    
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        res = [x[:] for x in matrix]
        for i in range(n):
            for j in range(n):
                matrix[j][n-i-1] = res[i][j]
</pre>
Time Complexity: O(n^2), Space Complexity: O(n^2).
<pre>
class Solution(object):
    
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        matrix.reverse()
        for i in range(len(matrix)):
            for j in range(i+1, len(matrix)):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 53. Maximum Subarray
<pre>
</pre>

## 54. Spiral Matrix
<pre>
class Solution(object):
    
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        res = []
        m = len(matrix)
        if m == 0:
            return res
        n = len(matrix[0])
        visited = [[False for _ in range(n)] for _ in range(m)]
        i = 0
        j = 0
        di = 0
        dj = 1
        while len(res) < m*n:
            res.append(matrix[i][j])
            visited[i][j] = True
            if i+di < 0 or i+di >= m or j+dj < 0 or j+dj >= n or visited[i+di][j+dj] == True:
                di, dj = dj, -di
            i += di
            j += dj
        return res
</pre>
Time Complexity: O(mn), Space Complexity: O(mn).

## 55. Jump Game
<pre>
</pre>

## 56. Merge Intervals
<pre>
</pre>

## 59. Spiral Matrix II
<pre>
class Solution(object):
    
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        res = [[0 for _ in range(n)] for _ in range(n)]
        i = 0
        j = 0
        di = 0
        dj = 1
        for k in range(1, n*n+1):           
            res[i][j] = k
            if i+di < 0 or i+di >= n or j+dj < 0 or j+dj >= n or res[i+di][j+dj] != 0:
                di, dj = dj, -di
            i += di
            j += dj
        return res
</pre>
Time Complexity: O(n^2), Space Complexity: O(n^2).

## 62. Unique Paths
<pre>
class Solution(object):
    
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        M = [[1]+[0]*(n-1)]*m
        M[0] = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                M[i][j] = M[i-1][j] + M[i][j-1]
        return M[m-1][n-1]
</pre>
Time Complexity: O(mn), Space Complexity: O(mn).

## 64. Minimum Path Sum
<pre>
class Solution(object):
    
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m = len(grid)
        n = len(grid[0])
        for i in range(m):
            for j in range(n):
                if i == 0 and j > 0:
                    grid[i][j] = grid[i][j-1] + grid[i][j]
                if j == 0 and i > 0:
                    grid[i][j] = grid[i-1][j] + grid[i][j]
                if i > 0 and j > 0:
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        return grid[m-1][n-1]
</pre>
Time Complexity: O(mn), Space Complexity: O(1).

## 78. Subsets
<pre>
class Solution(object):
    
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        self.helper(nums, [], res, len(nums))
        return res
        
    def helper(self, nums, path, res, n):
        if len(path) <= n:
            res.append(path)
        for i in range(len(nums)):
            self.helper(nums[i+1:], path+[nums[i]], res, n)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 79. Word Search
<pre>
class Solution(object):
    
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.helper(board, i, j, word):
                    return True
        return False
        
    def helper(self, board, i, j, word):
        if len(word) == 0:
            return True
        if i < 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1:
            return False
        if board[i][j] == word[0]:
            board[i][j] = '#'
            res = self.helper(board,i-1,j,word[1:]) or self.helper(board,i+1,j,word[1:]) or self.helper(board,i,j-1,word[1:]) or self.helper(board,i,j+1,word[1:])
            board[i][j] = word[0]
            return res
        else:
            return False
</pre>
Time Complexity: O(mnk), Space Complexity: O(1).

## 90. Subsets II
<pre>
class Solution(object):
    
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        self.helper(sorted(nums), [], res, len(nums))
        return res
        
    def helper(self, nums, path, res, n):
        if len(path) <= n:
            res.append(path)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            else:
                self.helper(nums[i+1:], path+[nums[i]], res, n)
</pre>
Time Complexity: max(O(# of combinations), O(nlog(n))), Space Complexity: O(n*(# of combinations)).

## 169. Majority Element
<pre>
class Solution(object):
    
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dict = {}
        n = len(nums)
        for i in range(n):
            if nums[i] in dict:
                dict[nums[i]] += 1
            else:
                dict[nums[i]] = 1
            if dict[nums[i]] > n/2:
                return nums[i]
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 189. Rotate Array
<pre>
class Solution(object):
    
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k%n
        nums[n-k:] = nums[n-k:][::-1]
        nums[:n-k] = nums[:n-k][::-1]
        nums = nums.reverse()
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 216. Combination Sum III
<pre>
class Solution(object):
    
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(range(1,10), k, n, [], res)
        return res
    
    def helper(self, candidates, k, n, path, res):        
        if k == 0 and sum(path) == n:
            res.append(path)
            return
        for i in range(len(candidates)):
            self.helper(candidates[i+1:], k-1, n, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 217. Contains Duplicate
<pre>
class Solution(object):
    
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        res = set()
        for i in range(len(nums)):
            if nums[i] in res:
                return True
            else:
                res.add(nums[i])
        return False
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 219. Contains Duplicate II
<pre>
class Solution(object):
    
    def containsNearbyDuplicate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        dict = {}
        for i in range(len(nums)):
            if nums[i] in dict and abs(i-dict[nums[i]]) <= k:
                return True
            else:
                dict[nums[i]] = i
        return False
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 268. Missing Number
<pre>
class Solution(object):
    
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return (1+len(nums))*len(nums)/2 - sum(nums)
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 283. Move Zeroes
<pre>
class Solution(object):
    
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[j] = nums[j], nums[i]
                j += 1
        return
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 628. Maximum Product of Three Numbers
<pre>
class Solution(object):
    
    def maximumProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        return max(nums[-1]*nums[-2]*nums[-3], nums[-1]*nums[0]*nums[1])
</pre>
Time Complexity: O(nlog(n)), Space Complexity: O(1).

## 643. Maximum Average Subarray I
<pre>
class Solution(object):
    
    def findMaxAverage(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: float
        """
        n = len(nums)
        res = average = sum(nums[:k])*1.0/k
        for i in range(k,n):
            average += (nums[i]-nums[i-k])*1.0/k
            res = max(res, average)
        return res
</pre>
Time complexity: O(n), Space Complexity: O(1).
